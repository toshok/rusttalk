use interp::Interpreter;
use primitive_ops::{not_implemented, PrimResult};

pub fn as_float(interp: &mut Interpreter) -> PrimResult {
    not_implemented(interp)
}
pub fn add(interp: &mut Interpreter) -> PrimResult {
    not_implemented(interp)
}
pub fn sub(interp: &mut Interpreter) -> PrimResult {
    not_implemented(interp)
}
pub fn lt(interp: &mut Interpreter) -> PrimResult {
    not_implemented(interp)
}
pub fn gt(interp: &mut Interpreter) -> PrimResult {
    not_implemented(interp)
}
pub fn le(interp: &mut Interpreter) -> PrimResult {
    not_implemented(interp)
}
pub fn ge(interp: &mut Interpreter) -> PrimResult {
    not_implemented(interp)
}
pub fn eq(interp: &mut Interpreter) -> PrimResult {
    not_implemented(interp)
}
pub fn ne(interp: &mut Interpreter) -> PrimResult {
    not_implemented(interp)
}
pub fn mul(interp: &mut Interpreter) -> PrimResult {
    not_implemented(interp)
}
pub fn div(interp: &mut Interpreter) -> PrimResult {
    not_implemented(interp)
}
pub fn trunc(interp: &mut Interpreter) -> PrimResult {
    not_implemented(interp)
}
pub fn frac(interp: &mut Interpreter) -> PrimResult {
    not_implemented(interp)
}
